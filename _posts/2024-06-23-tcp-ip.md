---
title: "TCP/IP란?"
date: 2024-06-23 21:20:00 +0900
categories: [Network]
tags: [basics, network, tcpip]
description: "TCP/IP의 개념과 OSI 7 계층과의 차이, TCP/IP 4계층 구조 및 연결 과정 정리"
image:
  path: /assets/img/thumbnails/tcp-ip.jpg
---

## TCP/IP란?

> 정의

흔히 TCP/IP라고 알려진 인터넷 프로토콜 스위트 (Internet Protocol Suite)는 인터넷과 이와 유사한 컴퓨터 네트워크 사이에서 정보를 주고받는 데 이용되는 통신 프로토콜의 모음이다.

IP는 데이터의 조각들을 최대한 빨리 목적지로 보내는 역할을 한다.
조각들의 순서가 뒤바뀌거나 일부가 누락되더라도 보내는데 집중을 하고
TCP는 IP보다 느리지만 꼼꼼한 방식을 사용하여 도착한 조각을 점검하고 줄을 세워 망가졌거나 빠진 조각을 다시 요청한다.
두 방식을 조합하여 인터넷 데이터 통신을 하는 것을 TCP/IP라고 부른다.


- TCP(Transmission Control Protocol) - 전송제어 프로토콜
  - 신뢰성 있는 데이터 전송을 제공하는 프로토콜이다.
  - 데이터의 손실이나 손상을 감지하고 복구할 수 있다.
  - 데이터를 작은 단위로 나누고, 각 단위에 일련번호를 부여하여 보낸 후, 수신 측에서 이를 재조립한다.
  - 데이터의 흐름 제어와 혼잡 제어 기능을 제공하여 네트워크의 혼잡을 방지하고 효율적인 전송을 도모한다.

- IP(Internet Protocol) - 인터넷 프로토콜
  - 패킷 스위칭 네트워크에서 데이터 패킷의 라우팅과 전달을 담당하는 프로토콜이다.
  - IP는 각각의 컴퓨터나 장치에 고유한 IP 주소를 할당하여 통신한다.
  - 패킷을 목적지로 전달하기 위해 최적의 경로를 선택한다.
  - 패킷을 여러 개로 나누어 전송하거나 조립하는 역할도 수행한다.

즉, TCP/IP는 인터넷 프로토콜 스위트의 핵심 프로토콜로, 신뢰성 있는 데이터 전송과 패킷의 라우팅을 담당하고,
인터넷을 비롯한 다양한 네트워크에서 사용되며, 안정적이고 효율적인 데이터 통신을 가능하게 한다.

- 패킷 : 네트워크가 전달하는 데이터의 형식화된 블록
- 패킷교환 :
  - 미리 이동 경로를 정하지 않고, 데이터를 패킷 (Packet)이라는 작은 단위로 나누어 다중 노드로 구성된 네트워크를 통해 전송하는 개념이다.
  - 전송될 데이터는 네트워크를 통해 전송되기 전에 패킷으로 쪼개어지고, 각 패킷에는 고유 번호가 지정되어 있어서 네트워크를 거쳐 최종 수신지에 도착했을 때에 번호 순서대로 결합되어 원래 데이터로 완성되는 방식이다.

<br>

---

## TCP/IP, OSI 7 비교

현재 TCP/IP는 OSI 7 계층보다 더욱 널리 사용되고 있는데 그 이유는 아래와 같다.

- 간결하고 경제적인 구조:
  - OSI 7 계층 모델은 7개의 계층으로 구성되어 있어 복잡하고 구현하기 어렵다.
  - 하지만 TCP/IP는 4개의 계층으로 구성되어 있어 구현과 관리가 간편하다.

- 인터넷에서의 표준 프로토콜:
  - TCP/IP는 인터넷의 기본 프로토콜로 사용되며, 인터넷의 발전과 함께 널리 통용되고 있는 프로토콜이다.
  - TCP/IP를 사용하면 다양한 네트워크와의 상호 운용성을 보장할 수 있습니다.

- 네트워크 관리의 용이성:
  - TCP/IP는 네트워크 관리와 모니터링에 있어서 효율적인 도구와 프로토콜을 제공한다.
  - TCP/IP 기반의 네트워크는 관리가 용이하며, 문제 발생 시 해결하기 쉽다.

- 널리 알려진 프로토콜:
  - TCP/IP는 다양한 애플리케이션과 서비스에서 사용되는 프로토콜을 포함하고 있다.
  - HTTP, FTP, SMTP 등의 프로토콜은 TCP/IP 위에서 동작하며, 이러한 프로토콜들은 널리 알려져 있고 지원되는 기능이 많다.


요약하자면, TCP/IP는 OSI 7 계층 모델보다 간편한 구조, 인터넷 표준 프로토콜, 더 쉬운 네트워크 관리, 널리 알려진 애플리케이션 및 서비스 지원, 그리고 인터넷과 함께 성장한 역사 때문에 더 널리 사용된다.

<br>

---

## TCP/IP 4계층(TCP/IP 4 Layer)

![](/assets/img/posts/network/tcp-ip/tcp-ip-4-layer.jpg)

TCP/IP의 4개 계층과 각 계층의 역할에 대한 설명이다.

### 1 계층 : 네트워크 인터페이스 계층 (Network Interface Layer)

- 물리적인 네트워크와의 인터페이스(정보를 교환하기 위한 매개체)를 담당한다.
- 이 계층은 이더넷, Wi-Fi, PPP(Point-to-Point Protocol) 등과 같은 네트워크 기술을 사용하여 데이터를 전송한다.
- 또한, MAC(Media Access Control) 주소와 같은 하드웨어적인 주소 체계를 사용하여 데이터를 목적지로 전달한다.
  <br>

### 2 계층 : 인터넷 계층 (Internet Layer)

- IP(Internet Protocol) 프로토콜을 기반으로 동작한다.
- 이 계층은 IP 주소를 사용하여 데이터를 라우팅 하고, 목적지까지 가장 효율적인 경로를 선택한다.
- 패킷을 분할하고 조립하여 전송하며, 패킷의 라우팅과 전달을 관리한다.
  <br>

### 3 계층 : 전송 계층 (Transport Layer)

- TCP(Transmission Control Protocol)와 UDP(User Datagram Protocol) 프로토콜을 포함한다.
- 이 계층은 데이터의 신뢰성, 흐름 제어, 혼잡 제어 등을 관리한다.
- TCP는 신뢰성 있는 연결 지향적인 전송을 제공하며, UDP는 신뢰성이 낮지만 빠른 전송을 지원한다.
- 이 계층은 포트 번호를 사용하여 애플리케이션 간의 데이터 흐름을 식별한다.
  <br>

### 4 계층 : 응용 계층 (Application Layer)

- HTTP, FTP, SMTP 등과 같은 다양한 응용 프로토콜을 포함한다.
- 이 계층은 사용자가 직접 상호 작용하는 애플리케이션과 네트워크 간의 통신을 관리한다.
- 응용 프로토콜은 사용자의 요구에 맞게 데이터의 형식과 규칙을 정의하며, 데이터의 전송을 처리한다.

<br>

---

## TCP 연결, 종료

### 연결

![](/assets/img/posts/network/tcp-ip/tcp-3-way.jpg)

server에서 포트는 litsen 상태이고 client에서는 closed 상태이다.

1. 클라이언트에서 서버에 연결 요청을 하기 위해 SYN을 보낸다.

2. 서버의 해당 포트는 LISTEN 상태에서 SYN 데이터를 받고 SYN_RCV 상태로 변경된다.
   이후 정상적으로 받았다는 대답으로 SYN + ACK를 보낸다.

3. 클라이언트에서는 SYN + ACK를 받고 ESTABLISHED 상태로 변경되고, 그 응답으로 ACK를 보낸다.
   이후 ACK를 받은 서버는 ESTABLISHED 상태로 변경된다.

이 3단계를 정상적으로 마치면, 서로 ESTABLISHED 되면서 연결이 성립된다.


> **STATE**

- CLOSED : 연결이 되어있지 않음을 나타내는 상태

- LISTEN : 원격 TCP application으로부터 연결 요청을 기다리고 있는 상태

- SYN_SENT : SYN(연결 요청)을 보낸 후 ACK(응답)을 기다리고 있는 상태 3 way handshake의 첫 번째 단계 후의 결과이다.

- SYN_RCV : 연결 요청을 받은 후 ACK를 보낸 후이며, 최종 ACK를 기다리고 있는 상태
  3 way handshake의 두 번째 단계 후의 결과이다.

- ESTABLISHED : 완전히 연결이 성립되었음을 나타내는 상태
  데이터 전송 단계에 대한 정상적인 상태를 나타낸다.
  <br>

### 종료

![](/assets/img/posts/network/tcp-ip/tcp-4-way.jpg)

TCP 연결 종료는 서로 ESTABLISHED 즉, 연결이 성립된 상태에서 시작한다.

1. 통신을 종료하고자 하는 클라이언트가 서버에게 FIN을 보낸 후, FIN_WAIT 1 상태로 대기한다.

2. FIN을 받은 서버는 상태를 CLOSE_WAIT로 변경하고, 응답으로 ACK를 보낸다.
해당 ACK를 받은 클라이언트는 상태를 FIN_WAIT 2로 변경한다.
이와 동시에 서버는 해당 포트에 연결되어 있는 애플리케이션에게 CLOSE()를 요청한다.

3. CLOSE() 요청을 받은 애플리케이션은 종료 프로세스를 통해 최종적으로 close 되고 서버는 FIN을 클라이언트에게 보낸 후 상태를 LAST_ACK로 변경한다.

4. FIN_WAIT 2 상태에서 서버로부터 FIN을 받으면 이에 대한 응답으로 ACK를 보낸 후 상태를 TIME_WAIT로 변경한다.
   최종 ACK를 받은 서버는 CLOSED로 상태를 변경하고, 클라이언트도 일정 시간이 지나면 CLOSED로 상태를 변경한다.

> **STATE**

- FIN_WAIT_1 : 연결 종료 요청에 대한 응답(ACK)을 기다리고 있는 상태

- FIN_WAIT_2 : 연결을 종료했다는 FIN(애플리케이션 종료)을 기다리고 있는 상태 
  - FIN을 받지 못했다면 서버에서 CLOSE()를 처리하지 못한 경우일 수도 있으며, 이 경우 FIN_WAIT 상태가 계속해서 지속될 수 있다.

- CLOSE_WAIT : 연결 종료 요청을 받았으며, 로컬 애플리케이션의 종료(CLOSE())를 기다리고 있는 상태

- LAST_ACK : 연결 종료 요청을 보냈으며 이에 대한 응답(ACK)을 기다리고 있는 상태 
  - 주로 서버에서 로컬 애플리케이션이 종료가 되고 클라이언트로 종료 요청을 보낸 후의 상태이다.

- TIME_WAIT : FIN에 대한 ACK를 보낸 후, 이를 원격지에서 받기까지 충분한 시간을 기다리고 있는 상태 
  - 일정 시간이 지나면 CLOSED 상태로 변경한다.
  <br><br><br><br><br><br><br><br><br><br>
  참고 : https://skstp35.tistory.com/250<br>
  참고 : https://velog.io/@dyunge_100/Network-TCPIP-4%EA%B3%84%EC%B8%B5%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC
