---
title: "추상화(Abstract)"
date: 2024-01-08 10:00:00 +0900
categories: [Java]
description: "추상화의 개념부터 추상 클래스, 인터페이스의 차이와 예제까지 정리합니다."
---

# 추상화란?

> 정의

- 핵심적인 개념, 기능을 간추려 내는 것
- 작업을 수행할 때 복잡한 것 들을 간단한 것처럼 보이게 만들어 주는 것
- 불필요한 것 들을 생략하고 객체의 속성 중 가장 중요한 것에만 중점을 두는 것

즉, 모델화 하는 것으로 데이터의 공통된 성질을 추출하는 것이다.
또 다른 말로는 인터페이스에 의존하고, 구체적인 구현에는 의존하지 않는 것이라고 할 수 있다.
ex) 토끼, 고양이, 강아지 가 있으면 동물이라고 묶어 추상화할 수 있다.

> 효과 / 장점

추상화를 사용하며 얻는 이점들은 아래와 같은 것들이 있다.

- 유지보수 시, 시간 단축
- 생산성 증가
- 에러 감소
- 코드의 가독성, 재사용성 증가
- 일관된 방향성

하지만 추상화를 했을 때 간단하게 사용할 수 있다는 점을 반대로 생각해 보면 내부가 얼마나 복잡한지 몰라서 쉽지 않다.

그리고 사용하려면 아래의 조건들이 선행돼야 한다.

- 추상 클래스는 추상 메서드를 한 개 이상 포함해야 한다.
- "abstract" 키워드를 사용하며, 추상 클래스 내에서만 선언할 수 있다.
- 반드시 다른 클래스에서 상속되어 오버라이딩 해야 사용이 가능하다. 즉 클래스의 설계도면의 역할을 하게 된다.

<br>

---

# 추상클래스

>정의

하나 이상의 추상 메서드를 포함하는 클래스를 가리켜 추상 클래스(abstract class)라고 한다.
추상 클래스를 상속받는 모든 클래스에서는 추상 메서드를 반드시 재정의 해야 한다.
일반 메서드로 구현한다면 사용자에 따라 구현할 수도 있고 안 할 수도 있지만, 추상메서드가 포함된 추상 클래스를 상속받은 모든 자식 클래스는 반드시 구현하게 되기 때문에 사용한다.

# 인터페이스

>정의

자식 클래스가 여러 부모 클래스를 상속받을 수 있다면, 다양한 동작을 수행할 수 있는 장점을 가질 수 있게 되지만 자바에서는 클래스를 통한 다중상속은 지원하지 않는다.
하지만 해당 이점을 버릴 수 없기 때문에 인터페이스를 통해 다중 상속을 지원하고 있다.
자바에서 추상클래스는 추상메서드, 생성자, 필드, 일반메서드도 포함할 수 있지만, 인터페이스는 추상메서드와 상수만 포함할 수 있다.
또한 추상클래스는 abstract를 사용하지만 인터페이스는 implements를 사용한다.

* 상수 : 변하지 말아야 할 데이터를 임시적으로 저장하기 위한 수단으로 사용된다. 즉 초기화 이후 재할당이 불가능하다.

# 추상클래스와 인터페이스의 차이

>정의

추상 클래스와 인터페이스는 상속받은 클래스 혹은 구현하는 인터페이스 안에 있는 추상메서드를 구현하도록 강제한다. 하지만 존재 목적이 다르다
하지만 추상클래스는 상속을 받아 기능을 이용하고 확장시키는 데 의미가 있다면 인터페이스는 상속을 받아 기능을 구현을 시키는 데 의미가 있다.
<br>

---

# 예제


```java
public abstract class Animal {
    String name;
    int age;

    public Animal(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public void move() {
        System.out.println("움직인다.");
    }

    public void eat() {
        System.out.println("먹는다.");
    }

    public abstract void bark(); // 동물마다 짖는 소리가 다르기 때문에 추상메서드로 생성
```

<br>

- 일반 클래스와 동일하게 필드, 생성자, 메서드를 선언할 수 있다.
- 자식객체가 생성될 때 super를 호출하기 때문에 생성자는 반드시 있어야 한다.
- 동물마다 짖는 소리가 다르기 때문에 bark() 메서드는 추상메서드로 생성하여 자식 클래스에서 오버라이드를 강제한다.

<br>

```java
public class Cat extends Animal{
    public Cat(String name, int age) {
        super(name, age);
    }

    @Override
    public void bark() { // 추상클래스를 상속받은 후 메서드 오버라이딩
        System.out.println("야옹~");
    }
}
```

```java
public class Dog extends Animal{
    public Dog(String name, int age) {
        super(name, age);
    }

    @Override
    public void bark() { // 추상클래스를 상속받은 후 메서드 오버라이딩
        System.out.println("멍멍!");
    }
}
```


- Cat, Dog 클래스를 만들어 추상클래스인 Animal을 상속받는다.
- 추상메서드로 강제된 오버라이드 bark()를 재정의 해 준다.

<br>

```java
public class Main {
    public static void main(String[] args) {
        Dog dog = new Dog("강아지", 3);
        Cat cat = new Cat("고양이", 5);

        cat.move();
        cat.bark();

        dog.move();
        dog.bark();

    }
}
```

- dog와 cat의 name과 age를 설정해 준다.
  <br>

>결과

```console
움직인다.
야옹~
움직인다.
멍멍!

종료 코드 0(으)로 완료된 프로세스
```

<br><br><br><br><br><br><br><br><br><br>

참고 : https://coding-factory.tistory.com/866
